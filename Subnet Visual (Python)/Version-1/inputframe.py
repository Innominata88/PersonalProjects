import tkinter as tk
import tkinter.font as tkfont
import tkinter.ttk as ttk
import socket
import struct
import webbrowser
from enum import IntEnum, unique
from dataclasses import dataclass
from functools import cached_property

from customtkip import *


@dataclass
class CIDRInfo:
    prefix: int

    @cached_property
    def host_bits(self):
        return 32 - self.prefix
    
    @cached_property
    def bitmap(self):
        return 'N' * self.prefix + 'H' * self.host_bits
    
    @cached_property
    def addresses(self):
        return 1 << (self.host_bits)
    
    @cached_property
    def usable_addresses(self):
        return self.addresses - 2 if self.addresses > 2 else 0

    @cached_property
    def netmask(self):
        return (0xFFFFFFFF << self.host_bits) & 0xFFFFFFFF
    
    @cached_property
    def netmask_quad(self):
        return socket.inet_ntoa(struct.pack('!I', self.netmask))
    
    @cached_property
    def netmask_quad_list(self):
        return list(map(int, self.netmask_quad.split('.')))
    
    @cached_property
    def netmask_hex_list(self):
        return [hex(value)[2:].zfill(2).upper() for value in self.netmask_quad_list]
    
    @cached_property
    def netmask_hex_quad(self):
        return '.'.join(self.netmask_hex_list)
    
    @cached_property
    def netmask_binary_list(self):
        return [bin(value)[2:].zfill(8) for value in self.netmask_quad_list]
    
    @cached_property
    def netmask_binary_quad(self):
        return '.'.join(self.netmask_binary_list)
    
    @cached_property
    def netmask_binary(self):
        return ''.join(self.netmask_binary_list)

    @cached_property
    def wildcard(self):
        return ~(0xFFFFFFFF << (self.host_bits)) & 0xFFFFFFFF
    
    @cached_property
    def wildcard_quad(self):
        return socket.inet_ntoa(struct.pack('!I', self.wildcard))
    
    @cached_property
    def wildcard_quad_list(self):
        return list(map(int, self.wildcard_quad.split('.')))
    
    @cached_property
    def wildcard_hex_list(self):
        return [hex(value)[2:].zfill(2).upper() for value in self.wildcard_quad_list]
    
    @cached_property
    def wildcard_hex_quad(self):
        return '.'.join(self.wildcard_hex_list)
    
    @cached_property
    def wildcard_binary_list(self):
        return [bin(value)[2:].zfill(8) for value in self.wildcard_quad_list]
    
    @cached_property
    def wildcard_binary_quad(self):
        return '.'.join(self.wildcard_binary_list)
    
    @cached_property
    def wildcard_binary(self):
        return ''.join(self.wildcard_binary_list)


@dataclass
class IPv4SummaryAddressFields:
    dotted_quad: tk.StringVar
    binary_quad: tk.StringVar
    hex_quad: tk.StringVar
    long: tk.StringVar
    binary_bits: list
    decimal_octets: list
    hex_octets: list


@dataclass
class IPv4SubnetFields:
    cidr_prefix: tk.StringVar
    addresses_per_subnet: tk.IntVar
    subnet_bits: tk.StringVar
    host_bits: tk.IntVar
    number_of_subnets: tk.IntVar


@dataclass
class IPv4SummaryFields:
    ip: IPv4SummaryAddressFields
    netmask: IPv4SummaryAddressFields
    wildcard: IPv4SummaryAddressFields
    network: IPv4SummaryAddressFields
    broadcast: IPv4SummaryAddressFields
    start_ip: IPv4SummaryAddressFields
    end_ip: IPv4SummaryAddressFields
    next_subnet: IPv4SummaryAddressFields
    public_or_private: tk.StringVar
    special_notes: tk.StringVar
    subnet: IPv4SubnetFields
    network_bits: tk.IntVar
    host_bits: tk.IntVar
    cidr_notation: tk.StringVar
    ip_class: tk.StringVar
    total_addresses: tk.IntVar
    usable_hosts: tk.IntVar
    mask_map: list
    subnet_map: list


@dataclass
class IPv4PracticeEntryFields:
    dotted_quad: list



@dataclass
class IPv4PracticeFields:
    target_ip: list
    target_cidr: tk.IntVar
    network_ip: list
    min_host: list
    max_host: list
    next_subnet: list
    # Need check answer and show answer


# generated by chat gpt
class Tooltip:
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tooltip = None
        self.widget.bind("<Enter>", self.show_tooltip)
        self.widget.bind("<Leave>", self.hide_tooltip)

    def show_tooltip(self, event):
        x, y, _, _ = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 25

        self.tooltip = tk.Toplevel(self.widget)
        self.tooltip.wm_overrideredirect(True)
        self.tooltip.wm_geometry(f"+{x}+{y}")

        label = tk.Label(self.tooltip, text=self.text, background="systemTextBackgroundColor")
        label.pack()

    def hide_tooltip(self, event):
        if self.tooltip:
            self.tooltip.destroy()
            self.tooltip = None


class MaskType(IntEnum):
    CIDR = 1
    NETMASK = 2
    WILDCARD = 3


class IPv4EntryFrame(tk.Frame):
    def __init__(self, 
                 container,
                 fields: IPv4SummaryFields,
                 cidr_info: list[CIDRInfo],
                 bordercolor: str = "systemTextColor",
                 outerborderwidths: BorderWidths = BorderWidths(2, 2, 2, 2),
                 innerborderwidth: int = 1,
                 width: str | float = 15, 
                 height: str | float = 15,
                 font=('TkFixedFont', 10),
                 dotfont=('TkFixedFont', 12, 'bold'),
                 justify=tk.CENTER,
                 **kwargs):
        tk.Frame.__init__(self, container)
        self.inner = tk.Frame(self)
        self.inner.grid(row=0, column=0)

        self.fields = fields
        self.cidr_info = cidr_info
        self.mask_type_var = tk.IntVar(value=MaskType.CIDR)
        self.cidr_font = ('TkFixedFont', 12, 'bold')

        self.maskopt = {}
        self.maskopt['cidr'] = tuple(range(33))
        self.maskopt['netmask'] = tuple(self.cidr_info[i].netmask_quad for i in range(33))
        self.maskopt['wildcard'] = tuple(self.cidr_info[i].wildcard_quad for i in range(33))

        self.bin_octet_frames = []
        self.dec_octet_frames = []

        self.mask = tk.StringVar()
        self.mask.trace("w", lambda *args: self._set_mask(*args))

        self.fields.ip.long.trace("w", lambda *args: self._set_network(*args))

        bin_row = 1
        dec_row = 0
        label_padx = (1, 1)
        label_pady = (2, 2)

        for i in range(32):
            self.fields.ip.binary_bits[i].trace("w", lambda *args, i=i: self.update_binary_quad(*args, bit_idx=i))

        tk.Label(self.inner, text="Decimal:", compound=tk.CENTER, font=font).grid(row=dec_row, column=0, pady=label_pady, padx=label_padx, sticky="E")
        tk.Label(self.inner, text="Bit Value:", compound=tk.CENTER, font=font).grid(row=bin_row, column=0, pady=label_pady, padx=label_padx, sticky="E")

        idx = 1
        for i in range(0, 32, 8):
            octet = CombFrame(self.inner, 
                              varslist=self.fields.ip.binary_bits[i:i+8], 
                              bordercolor=bordercolor, 
                              outerborderwidths=outerborderwidths, 
                              innerborderwidth=innerborderwidth, 
                              width=width, 
                              height=height, 
                              font=font,
                              **kwargs)
            octet.grid(row=bin_row, column=idx, sticky="NSEW", pady=label_pady, padx=label_padx)
            idx += 1
            self.bin_octet_frames.append(octet)
                        
            if idx < 7:
                tk.Label(self.inner, text=" ", font=dotfont).grid(row=bin_row, column=idx)
                idx += 1
        
        idx = 1
        validate_decimal = self.register(self.validate_decimal_octet)
        for i in range(4):
            octet = tk.Entry(self.inner, textvariable=self.fields.ip.decimal_octets[i], width=3, justify=justify, validate="key", validatecommand=(validate_decimal, "%P"))
            octet.grid(row=dec_row, column=idx, sticky="NSEW", padx=label_padx, pady=label_pady)
            self.dec_octet_frames.append(octet)
            
            self.fields.ip.decimal_octets[i].trace("w", lambda *args, i=i: self.update_decimal_octet(*args, octet=i))
            octet.bind("<FocusOut>", lambda event, i=i: self._set_default_decimal_octet(event, i))
            octet.bind("<FocusIn>", lambda event, i=i: self._remove_default_decimal_octet_focusin(event, i))

            idx += 1

            if idx < 7:
                tk.Label(self.inner, text=".", font=dotfont).grid(row=dec_row, column=idx)
                idx += 1

        Tooltip(self.dec_octet_frames[0], "First Octet")
        Tooltip(self.dec_octet_frames[1], "Second Octet")
        Tooltip(self.dec_octet_frames[2], "Third Octet")
        Tooltip(self.dec_octet_frames[3], "Fourth Octet")

        for i in range(8):
            self.bin_octet_frames[0].cells[i].interior.label.bind("<Button-1>", lambda event, i=i: self.toggle_bit(event, i, 0, 7-i, 31-i))
            self.bin_octet_frames[1].cells[i].interior.label.bind("<Button-1>", lambda event, i=i: self.toggle_bit(event, 8+i,1, 7-i, 31-8-i))
            self.bin_octet_frames[2].cells[i].interior.label.bind("<Button-1>", lambda event, i=i: self.toggle_bit(event, 16+i, 2, 7-i, 31-16-i))
            self.bin_octet_frames[3].cells[i].interior.label.bind("<Button-1>", lambda event, i=i: self.toggle_bit(event, 24+i, 3, 7-i, 31-24-i))

            Tooltip(self.bin_octet_frames[0].cells[i].interior.label, (1 << (7-i)))
            Tooltip(self.bin_octet_frames[1].cells[i].interior.label, (1 << (7-i)))
            Tooltip(self.bin_octet_frames[2].cells[i].interior.label, (1 << (7-i)))
            Tooltip(self.bin_octet_frames[3].cells[i].interior.label, (1 << (7-i)))


        tk.Label(self.inner, text="/", font=('TkFixedFont', 25, 'bold')).grid(row=dec_row, column=8, rowspan=2, padx=2)
        radio_padx = (2, 2)
        radio_pady = (0, 0)

        self.input_type_frame = tk.LabelFrame(self, text="Mask Format", font=font)
        self.input_type_frame.grid(row=1, column=0, ipady=5, ipadx=5, pady=5, padx=5)

        self.mask_toggle_cidr = tk.Radiobutton(self.input_type_frame, text="CIDR Prefix", variable=self.mask_type_var, value=MaskType.CIDR, font=font, command=self.toggle_mask_dropdown)
        self.mask_toggle_netmask = tk.Radiobutton(self.input_type_frame, text="Netmask", variable=self.mask_type_var, value=MaskType.NETMASK, font=font, command=self.toggle_mask_dropdown)
        self.mask_toggle_wildcard = tk.Radiobutton(self.input_type_frame, text="Wildcard", variable=self.mask_type_var, value=MaskType.WILDCARD, font=font, command=self.toggle_mask_dropdown)
        self.mask_toggle_cidr.grid(row=0, column=0, padx=radio_padx, pady=radio_pady, sticky="W")
        self.mask_toggle_netmask.grid(row=0, column=1, padx=radio_padx, pady=radio_pady, sticky="W")
        self.mask_toggle_wildcard.grid(row=0, column=2, padx=radio_padx, pady=radio_pady, sticky="W")
        
        self.mask_box = ttk.Combobox(self.inner, justify=tk.CENTER, textvariable=self.mask, font=self.cidr_font, values=self.maskopt['cidr'], width=13, state="readonly")
        self.mask_box.grid(row=dec_row, column=9, rowspan=2)
        self.mask_box.current(0)

        self._set_mask(is_init=True)


    def toggle_mask_dropdown(self):
        idx = self.mask_box.current()
        mask_type = self.mask_type_var.get()

        if mask_type == MaskType.NETMASK:
            self.mask_box.config(values=self.maskopt['netmask'])
        elif mask_type == MaskType.WILDCARD:
            self.mask_box.config(values=self.maskopt['wildcard'])
        else:
            self.mask_box.config(values=self.maskopt['cidr'])

        self.mask_box.current(idx)


    def toggle_bit(self, event, bit_index, octet, bit_position, absolute_bit_position):
        bit = self.fields.ip.binary_bits[bit_index].get()

        quad_value = self._get_decimal_octet(octet)
        
        packed =  self._get_long_ip()
        
        if bit == '1':
            self.fields.ip.binary_bits[bit_index].set(0)
            self.fields.ip.decimal_octets[octet].set((quad_value & ~(1 << bit_position)))
            self.fields.ip.long.set((packed & ~(1 << absolute_bit_position)))
        else:
            self.fields.ip.binary_bits[bit_index].set(1)
            self.fields.ip.decimal_octets[octet].set((quad_value | (1 << bit_position)))
            self.fields.ip.long.set((packed | (1 << absolute_bit_position)))

    
    def validate_decimal_octet(self, P):
        if P.isdigit():
            try:
                return len(P) < 3 or (0 <= int(P, 10) <= 255)
            except ValueError:
                return False
        return not P

    
    def update_decimal_octet(self, *args, octet: int):
        value = self._get_decimal_octet(octet)

        bits = bin(value)[2:].zfill(8)
        for i in range(8):
            self.fields.ip.binary_bits[(octet * 8) + i].set(bits[i])

        self.fields.ip.hex_octets[octet].set((hex(value)[2:].zfill(2)).upper())
        self.fields.ip.long.set((self._get_decimal_octet(0) << 24) 
                        | (self._get_decimal_octet(1)<< 16) 
                        | (self._get_decimal_octet(2)<< 8) 
                        | (self._get_decimal_octet(3)))
        
        packed = self._get_long_ip().to_bytes(4, byteorder="big")
        self.fields.ip.dotted_quad.set('.'.join([str(byte) for byte in packed]))
        self.fields.ip.hex_quad.set('.'.join([hex(byte)[2:].zfill(2).upper() for byte in packed]))
        self._is_public_or_private()
        self._is_special()
        
        if octet == 0:
            self._set_ip_class(bits)


    def update_binary_quad(self, *args, bit_idx: int):
        self.fields.ip.binary_quad.set('.'.join([''.join([self.fields.ip.binary_bits[(8*i)+j].get() for j in range(8)]) for i in range(4)]))


    def _get_long_ip(self):
        try:
            return int(self.fields.ip.long.get(), 10)
        except ValueError:
            return 0
        
    def _is_public_or_private(self):
        ip = self._get_long_ip()
        # 10.0.0.0/8 or 172.16.0.0/12 or 192.168.0.0/16
        # https://datatracker.ietf.org/doc/html/rfc1918
        if ((ip & 4278190080) == 167772160 or (ip & 4293918720) == 2886729728 or (ip & 4294901760) == 3232235520):
            self.fields.public_or_private.set("Private")
        else:
            self.fields.public_or_private.set("Public")
        
    def _is_special(self):
        ip = self._get_long_ip()
        # https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml
        # 0.0.0.0/32
        if ip == 0:
            self.fields.special_notes.set('"This host on this network"')
        # 192.0.0.8/32
        elif ip == 3221225480:
            self.fields.special_notes.set('IPv4 dummy address')
        # 192.0.0.9/32
        elif ip == 3221225481:
            self.fields.special_notes.set('Port Control Protocol Anycast')
        # 192.0.0.10/32
        elif ip == 3221225482:
            self.fields.special_notes.set('Traversal Using Relays around NAT Anycast')
        # 192.0.0.170/32 or 192.0.0.171/32
        elif ip == 3221225642 or ip == 3221225643:
            self.fields.special_notes.set('NAT64/DNS64 Discovery')
        # 255.255.255.255/32
        elif ip == 4294967295:
            self.fields.special_notes.set('Limited Broadcast')
        elif (ip & 4294967288) == 3221225472:
            self.fields.special_notes.set('IPv4 Service Continuity Prefix')
        else:
            # Input IP /24
            block24 = ip & 4294967040

            # 192.0.0.0/24
            if block24 == 3221225472:
                self.fields.special_notes.set('IETF Protocol Assignments')
            # 192.0.2.0/24
            elif block24 == 3221225984:
                self.fields.special_notes.set('Documentation (TEST-NET-1)')
            # 192.31.196.0/24
            elif block24 == 3223307264:
                self.fields.special_notes.set('AS112-v4')
            # 192.52.193.0/24
            elif block24 == 3224682752:
                self.fields.special_notes.set('AMT')
            # 192.175.48.0/24
            elif block24 == 3232706560:
                self.fields.special_notes.set('Direct Delegation AS112 Service')
            # 198.51.100.0/24
            elif block24 == 3325256704:
                self.fields.special_notes.set('Documentation (TEST-NET-2)')
            # 203.0.113.0/24
            elif block24 == 3405803776:
                self.fields.special_notes.set('Documentation (TEST-NET-3)')
            # 169.254.0.0/16
            elif (ip & 4294901760) == 2851995648:
                self.fields.special_notes.set('Link Local')
            # 198.18.0.0/15
            elif (ip & 4294836224) == 3323068416:
                self.fields.special_notes.set('Benchmarking')
            # 100.64.0.0/10
            elif (ip & 4290772992) == 1681915904:
                self.fields.special_notes.set('Shared Address Space')
            # 0.0.0.0/8
            elif (ip & 4278190080) == 0:
                self.fields.special_notes.set('"This network"')
            # 127.0.0.0/8
            elif (ip & 4278190080) == 2130706432:
                self.fields.special_notes.set('Loopback')
            # 240.0.0.0/4
            elif (ip & 4026531840) == 4026531840:
                self.fields.special_notes.set('Reserved')
            else:
                self.fields.special_notes.set('N/A')


    def _get_long_masks(self):
        try:
            netmask = int(self.fields.netmask.long.get(), 10)
        except ValueError:
            netmask = 0

        try:
            wildcard = int(self.fields.wildcard.long.get(), 10)
        except ValueError:
            wildcard = 0

        return netmask, wildcard
    

    def _get_decimal_octet(self, octet):
        try:
            return int(self.fields.ip.decimal_octets[octet].get(), 10)
        except ValueError:
            return 0
        

    def _set_default_decimal_octet(self, event, octet):
        self.fields.ip.decimal_octets[octet].set(self._get_decimal_octet(octet))


    def _remove_default_decimal_octet_focusin(self, event, octet):
        if self._get_decimal_octet(octet) == 0:
            self.fields.ip.decimal_octets[octet].set("")


    def _set_ip_class(self, first_octet):
        self.fields.ip_class.set(
            'A' if first_octet[0] == '0' else \
            'B' if first_octet[0:2] == '10' else \
            'C' if first_octet[0:3] == '110' else\
            'D' if first_octet[0:4] == '1110' else\
            'E')
             
    def _init_ip_fields(self):
        self.fields.ip_class.set('A')
        self.fields.ip.binary_quad.set('00000000.00000000.00000000.00000000')
        self.fields.ip.dotted_quad.set('0.0.0.0')
        self.fields.ip.hex_quad.set('00.00.00.00')

        for i in range(4):
            self.fields.ip.decimal_octets[i].set(0)
            self.fields.ip.hex_octets[i].set('00')


    def _set_mask(self, *args, is_init=False):
        mask = self.mask_box.current()
        
        # Mask did not change (dropdown did)
        if mask == self.fields.network_bits.get() and not is_init:
            return
        
        self.fields.network_bits.set(mask)
        self.fields.host_bits.set(32 - mask)
        self.fields.total_addresses.set(self.cidr_info[mask].addresses)
        self.fields.usable_hosts.set(self.cidr_info[mask].usable_addresses)

        self.fields.netmask.dotted_quad.set(self.cidr_info[mask].netmask_quad)
        self.fields.netmask.long.set(self.cidr_info[mask].netmask)
        self.fields.netmask.hex_quad.set(self.cidr_info[mask].netmask_hex_quad)
        self.fields.netmask.binary_quad.set(self.cidr_info[mask].netmask_binary_quad)

        self.fields.wildcard.dotted_quad.set(self.cidr_info[mask].wildcard_quad)
        self.fields.wildcard.long.set(self.cidr_info[mask].wildcard)
        self.fields.wildcard.hex_quad.set(self.cidr_info[mask].wildcard_hex_quad)
        self.fields.wildcard.binary_quad.set(self.cidr_info[mask].wildcard_binary_quad)

        for i in range(4):
            self.fields.netmask.decimal_octets[i].set(self.cidr_info[mask].netmask_quad_list[i])
            self.fields.netmask.hex_octets[i].set(self.cidr_info[mask].netmask_hex_list[i])

            self.fields.wildcard.decimal_octets[i].set(self.cidr_info[mask].wildcard_quad_list[i])
            self.fields.wildcard.hex_octets[i].set(self.cidr_info[mask].wildcard_hex_list[i])

        for i in range(32):
            self.fields.netmask.binary_bits[i].set(self.cidr_info[mask].netmask_binary[i])
            self.fields.wildcard.binary_bits[i].set(self.cidr_info[mask].wildcard_binary[i])
            self.fields.mask_map[i].set(self.cidr_info[mask].bitmap[i])

        self._set_network(*args)

    
    def _set_network(self, *args):
        ip = self._get_long_ip()
        netmask, wildcard = self._get_long_masks()

        self.fields.cidr_notation.set(self.fields.ip.dotted_quad.get() + '/' + str(self.fields.network_bits.get()))

        network = ip & netmask
        broadcast = ip | wildcard

        network_fields = self._calculate_fields(network)
        self.fields.network.dotted_quad.set(network_fields[0])
        self.fields.network.binary_quad.set(network_fields[1])
        self.fields.network.hex_quad.set(network_fields[2])
        self.fields.network.long.set(network_fields[3])

        broadcast_fields = self._calculate_fields(broadcast)
        self.fields.broadcast.dotted_quad.set(broadcast_fields[0])
        self.fields.broadcast.binary_quad.set(broadcast_fields[1])
        self.fields.broadcast.hex_quad.set(broadcast_fields[2])
        self.fields.broadcast.long.set(broadcast_fields[3])

        for i in range(32):
            self.fields.network.binary_bits[i].set(network_fields[4][i])
            self.fields.broadcast.binary_bits[i].set(broadcast_fields[4][i])

        for i in range(4):
            self.fields.network.decimal_octets[i].set(network_fields[5][i])
            self.fields.network.hex_octets[i].set(network_fields[6][i])
            
            self.fields.broadcast.decimal_octets[i].set(broadcast_fields[5][i])
            self.fields.broadcast.hex_octets[i].set(broadcast_fields[6][i])

        if broadcast - network > 1:
            start_fields = self._calculate_fields(network + 1)
            end_fields = self._calculate_fields(broadcast - 1)

            for i in range(32):
                self.fields.start_ip.binary_bits[i].set(start_fields[4][i])
                self.fields.end_ip.binary_bits[i].set(end_fields[4][i])

            for i in range(4):
                self.fields.start_ip.decimal_octets[i].set(start_fields[5][i])
                self.fields.start_ip.hex_octets[i].set(start_fields[6][i])
                
                self.fields.end_ip.decimal_octets[i].set(end_fields[5][i])
                self.fields.end_ip.hex_octets[i].set(end_fields[6][i])
        else:
            start_fields = ['N/A'] * 6
            end_fields = ['N/A'] * 6
            
        self.fields.start_ip.dotted_quad.set(start_fields[0])
        self.fields.start_ip.binary_quad.set(start_fields[1])
        self.fields.start_ip.hex_quad.set(start_fields[2])
        self.fields.start_ip.long.set(start_fields[3])

        self.fields.end_ip.dotted_quad.set(end_fields[0])
        self.fields.end_ip.binary_quad.set(end_fields[1])
        self.fields.end_ip.hex_quad.set(end_fields[2])
        self.fields.end_ip.long.set(end_fields[3])

        # Valid IP for next subnet
        if broadcast + 1 <= 4294967295:
            next_subnet = self._calculate_fields(broadcast + 1)

            for i in range(32):
                self.fields.next_subnet.binary_bits[i].set(next_subnet[4][i])

            for i in range(4):
                self.fields.next_subnet.decimal_octets[i].set(next_subnet[5][i])
                self.fields.next_subnet.hex_octets[i].set(next_subnet[6][i])
        else:
            next_subnet = ['N/A'] * 6

        self.fields.next_subnet.dotted_quad.set(next_subnet[0])
        self.fields.next_subnet.binary_quad.set(next_subnet[1])
        self.fields.next_subnet.hex_quad.set(next_subnet[2])
        self.fields.next_subnet.long.set(next_subnet[3])


    def _calculate_fields(self, ip: int):
        packed = ip.to_bytes(4, 'big')
        decimal_octets = [str(b) for b in packed]
        hex_octets = [hex(b)[2:].zfill(2).upper() for b in packed]
        binary_octets = [bin(b)[2:].zfill(8) for b in packed]

        #dotted_quad binary_quad hex_quad long binary_bits decimal_octets hex_octets

        return ['.'.join(decimal_octets), '.'.join(binary_octets), '.'.join(hex_octets), ip, ''.join(binary_octets), decimal_octets, hex_octets]
    

class InputSummaryImageFrame(tk.Frame):
    def __init__(self, 
                 container,
                 ip: IPv4SummaryAddressFields,
                 mask: IPv4SummaryAddressFields,
                 fields: IPv4SummaryFields,
                 bordercolor: str = "systemTextColor",
                 outerborderwidths: BorderWidths = BorderWidths(2, 2, 2, 2),
                 innerborderwidth: int = 1,
                 width: str | float = 15, 
                 height: str | float = 15,
                 font=('TkFixedFont', 10),
                 dotfont=('TkFixedFont', 12, 'bold'),
                 bitnumfont=('TkFixedFont', 8),
                 **kwargs):
            tk.Frame.__init__(self, container)

            self.fields = fields
            self.colors = {"network": "red", "host": "green", "subnet": "orange"}

            self.visual_frame = tk.LabelFrame(self, text="IP Visual", font=font)
            self.visual_frame.grid(column=0, row=0, sticky="NSEW", ipadx=5, ipady=5, padx=5, pady=5, rowspan=3, columnspan=5)

            self.inner = tk.Frame(self.visual_frame)
            self.inner.grid(column=1, row=1, columnspan=5)

            #self.font2 = font=('TkFixedFont', 8)

            bit_significance_row = 0
            span_arrow_row = 1
            quad_arrows_row = 2
            mask_row = 3
            bitmap_row = 4
            subnet_bitmap_row = 5
            input_ip_row = 6
            bit_num_row = 7
            class_arrow_row = 8
            octet_label_row = 9

            tk.Label(self.inner, text="Input:", font=font).grid(row=input_ip_row, column=0, padx=5, sticky="E")
            tk.Label(self.inner, text="Netmask:", font=font).grid(row=mask_row, column=0, padx=5, sticky="E")
            tk.Label(self.inner, text="Network/Host:", font=font).grid(row=bitmap_row, column=0, padx=5, sticky="E")
            tk.Label(self.inner, text="Host/Subnet:", font=font).grid(row=subnet_bitmap_row, column=0, padx=5, sticky="E")
            tk.Label(self.inner, text="Class Bits:", font=font).grid(row=class_arrow_row, column=0, padx=5, sticky="E")

            self.ip_octet_frames = []
            self.ip_bitmap_frames = []
            self.ip_subnet_frames = []
            self.bit_num_frames = []
            self.ip_mask_frames = []
            self.ip_bitmap_subnet_frames = []

            bg = self.cget("bg")
            octet_names = ["First", "Second", "Third", "Fourth"]
            self.class_colors = {
                'A': ["systemTextColor", bg, bg, bg],
                'B': ["systemTextColor", "systemTextColor", bg, bg],
                'C': ["systemTextColor", "systemTextColor", "systemTextColor", bg],
                'D': ["systemTextColor", "systemTextColor", "systemTextColor", "systemTextColor"],
                'E': ["systemTextColor", "systemTextColor", "systemTextColor", "systemTextColor"]
            }

            # Header Frame
            tk.Label(self.inner, text="Most Significant Bit", font=('TkFixedFont', 10, 'italic'), height=1).grid(row=bit_significance_row, column=1, sticky="W", ipady=0, pady=0)
            tk.Label(self.inner, text="Least Significant Bit", font=('TkFixedFont', 10, 'italic'), height=1).grid(row=bit_significance_row, column=7, sticky="E", ipady=0, pady=0)

            self.span_frame = tk.Frame(self.inner)
            self.span_frame.grid(row=span_arrow_row, column=1, ipadx=5, columnspan=7, sticky="NSEW")
            self.span_frame.grid_columnconfigure(0, weight=1)
            self.fields.subnet.subnet_bits.set(0)

            tk.Label(self.span_frame, text="32 bits / 4 bytes", font=('TkFixedFont', 10, 'italic'), height=1, justify=tk.CENTER, anchor=tk.CENTER).grid(row=0, column=0, sticky="NSEW", ipady=0, pady=0)
            
            self.span_canvas = tk.Canvas(self.span_frame, height=7)
            self.span_canvas.grid(row=1, column=0, sticky="NSEW", pady=0)
            self.span_canvas.bind("<Configure>", lambda event, canvas=self.span_canvas, arrow=tk.BOTH: self._draw_arrow(event, canvas, arrow))

            idx = 1
            for i in range(0, 32, 8):
                b = BorderedFrame(self.inner, interior=tk.Frame, bordercolor=bordercolor, borderwidths=BorderWidths(1, 1, 0, 0), height=15)
                b.grid(row=quad_arrows_row, column=idx, sticky="NSEW")
                b.interior.grid(ipady=5)
                b.interior.grid_columnconfigure(0, weight=1)

                tk.Label(b.interior, text="8 bits / 1 byte", font=('TkFixedFont', 10, 'italic'), height=1, justify=tk.CENTER, anchor=tk.CENTER).grid(row=0, column=0, pady=0)

                canvas = tk.Canvas(b.interior, height=7, width=5)
                canvas.grid(row=1, column=0, sticky="NSEW", ipadx=5, ipady=0, pady=0)
                canvas.bind("<Configure>", lambda event, canvas=canvas, arrow=tk.BOTH: self._draw_arrow(event, canvas, arrow))
    
                octet = CombFrame(self.inner, 
                                varslist=ip.binary_bits[i:i+8], 
                                bordercolor=bordercolor, 
                                outerborderwidths=outerborderwidths, 
                                innerborderwidth=innerborderwidth, 
                                width=width, 
                                height=height, 
                                font=font,
                                bg=self.colors["host"],
                                justify=tk.CENTER,
                                **kwargs)
                octet.grid(row=input_ip_row, column=idx, pady=0, sticky="NSEW")
                self.ip_octet_frames.append(octet)

                mask_octet = CombFrame(self.inner, 
                                varslist=mask.binary_bits[i:i+8], 
                                bordercolor=bordercolor, 
                                outerborderwidths=outerborderwidths, 
                                innerborderwidth=innerborderwidth, 
                                width=width, 
                                height=height, 
                                font=font,
                                bg=self.colors["host"],
                                justify=tk.CENTER,
                                **kwargs)
                mask_octet.grid(row=mask_row, column=idx, pady=0, sticky="NSEW")
                self.ip_mask_frames.append(mask_octet)

                bitmap_comb = CombFrame(self.inner, 
                                varslist=self.fields.mask_map[i:i+8], 
                                bordercolor=bordercolor, 
                                outerborderwidths=outerborderwidths, 
                                innerborderwidth=innerborderwidth, 
                                width=width, 
                                height=height, 
                                font=font,
                                bg=self.colors["host"],
                                justify=tk.CENTER,
                                **kwargs)
                bitmap_comb.grid(row=bitmap_row, column=idx, pady=0, sticky="NSEW")
                self.ip_bitmap_frames.append(bitmap_comb)

                bitmap_subnet_comb = CombFrame(self.inner, 
                                varslist=self.fields.subnet_map[i:i+8], 
                                bordercolor=bordercolor, 
                                outerborderwidths=outerborderwidths, 
                                innerborderwidth=innerborderwidth, 
                                width=width, 
                                height=height, 
                                font=font,
                                bg=self.colors["host"],
                                justify=tk.CENTER,
                                **kwargs)
                bitmap_subnet_comb.grid(row=subnet_bitmap_row, column=idx, pady=0, sticky="NSEW")
                self.ip_bitmap_subnet_frames.append(bitmap_subnet_comb)

                bit_num = CombFrame(self.inner, 
                                textlist=list(range(i,i+8)), 
                                bordercolor=bg, 
                                outerborderwidths=BorderWidths(2, 2, 0, 0),
                                innerborderwidth=innerborderwidth, 
                                width=width, 
                                height=height, 
                                font=bitnumfont,
                                justify=tk.CENTER,
                                **kwargs)
                bit_num.grid(row=bit_num_row, column=idx, pady=0, sticky="NSEW")
                self.bit_num_frames.append(bitmap_comb)
                
                tk.Label(self.inner, text=f"{octet_names[i//8]} Octet", font=('TkFixedFont', 10, 'bold'), height=1, justify=tk.CENTER, anchor=tk.CENTER).grid(row=octet_label_row, column=idx, pady=0, sticky="NSEW")
                
                idx += 1

                if idx < 7:
                    tk.Label(self.inner, text=" ", font=dotfont).grid(row=mask_row, column=idx)
                    tk.Label(self.inner, text=" ", font=dotfont).grid(row=input_ip_row, column=idx)
                    tk.Label(self.inner, text=" ", font=dotfont).grid(row=bitmap_row, column=idx)
                    tk.Label(self.inner, text=" ", font=dotfont).grid(row=subnet_bitmap_row, column=idx)
                    tk.Label(self.inner, text=" ", font=dotfont).grid(row=bit_num_row, column=idx)
                    idx += 1

            for i in range(32):
                self.fields.mask_map[i].trace("w", lambda *args, i=i: self._set_mask_colors(*args, bit_index=i))
                self.fields.subnet_map[i].trace("w", lambda *args, i=i: self._set_subnet_colors(*args, bit_index=i))

            
            self.ip_class_arrows = CombFrame(self.inner, 
                                textlist=["\u21E7"]*4 + [""] * 4,
                                outerborderwidths=BorderWidths(2, 2, 0, 0),
                                innerborderwidth=innerborderwidth,
                                width=width, 
                                height=height,
                                fg=bg, 
                                font=font,
                                **kwargs)
            self.ip_class_arrows.grid(row=class_arrow_row, column=1, sticky="NSEW", pady=0)

            self.ip_class_arrows.cells[0].interior.label.config(fg=self.class_colors['A'][0])
            self.fields.ip_class.trace("w", lambda *args: self._set_class(*args))

            cidr_frame = tk.LabelFrame(self, text="This Subnet", font=font)
            cidr_frame.grid(column=0, row=3, ipadx=5, ipady=5, padx=5, sticky="NSEW")

            tk.Label(cidr_frame, text="CIDR Notation:", font=font).grid(column=0, row=0, sticky="E")
            cidr_prefix = BorderedFrame(cidr_frame, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=16, justify=tk.CENTER, textvariable=self.fields.cidr_notation, font=font, state="readonly", readonlybackground="systemTextBackgroundColor")
            cidr_prefix.grid(column=1, row=0, pady=5, sticky="W", columnspan=3)

            tk.Label(cidr_frame, text="Network Bits: ", font=font).grid(column=0, row=1, sticky="E")
            network_bits = BorderedFrame(cidr_frame, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=2, justify=tk.CENTER, textvariable=self.fields.network_bits, bd=0, font=font, state="readonly", highlightbackground=self.colors["network"], readonlybackground=self.colors["network"])
            network_bits.grid(column=1, row=1, pady=5, sticky="W")

            tk.Label(cidr_frame, text="Host Bits: ", font=font).grid(column=2, row=1, sticky="E")
            host_bits = BorderedFrame(cidr_frame, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=2, justify=tk.CENTER, textvariable=self.fields.host_bits, bd=0, font=font, state="readonly", highlightbackground=self.colors["host"], readonlybackground=self.colors["host"])
            host_bits.grid(column=3, row=1, padx=(5, 0), pady=5, sticky="W")

            tk.Label(cidr_frame, text="Total Addresses:", font=font).grid(column=0, row=2, sticky="E")
            total_addresses = BorderedFrame(cidr_frame, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=15, justify=tk.CENTER, textvariable=self.fields.total_addresses, font=font, state="readonly", readonlybackground="systemTextBackgroundColor")
            total_addresses.grid(column=1, row=2, pady=5, sticky="W", columnspan=3)

            tk.Label(cidr_frame, text="Usable Hosts:", font=font).grid(column=0, row=3, sticky="E")
            usable_hosts = BorderedFrame(cidr_frame, borderwidths=BorderWidths(1,1,1,1), bordercolor="#BD86FF", interior=tk.Entry, width=15, justify=tk.CENTER, textvariable=self.fields.usable_hosts, font=font, state="readonly", readonlybackground="systemTextBackgroundColor")
            usable_hosts.grid(column=1, row=3, pady=5, sticky="W", columnspan=3)

            network_bits.interior.config(bg=self.colors["network"])

            subnet_frame = tk.LabelFrame(self, text="Other Subnets", font=font)
            subnet_frame.grid(column=5, row=2, ipadx=5, ipady=5, rowspan=2)
            tk.Label(subnet_frame, text="Subnet Bits:", font=font).grid(column=0, row=0, sticky="E")
            self.subnet_spinbox = tk.Spinbox(subnet_frame, from_=0, to=32, textvariable=self.fields.subnet.subnet_bits, font=font, justify=tk.CENTER, width=5, wrap=True)
            self.subnet_spinbox.grid(column=1, row=0, sticky="NSEW", columnspan=3)

            tk.Label(subnet_frame, text="Subnet CIDR:", font=font).grid(column=0, row=1, sticky="E")
            subnet_cidr_prefix = BorderedFrame(subnet_frame, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=16, justify=tk.CENTER, textvariable=self.fields.subnet.cidr_prefix, font=font, state="readonly", readonlybackground="systemTextBackgroundColor")
            subnet_cidr_prefix.grid(column=1, row=1, pady=5, sticky="W", columnspan=3)

            tk.Label(subnet_frame, text="Subnet Bits: ", font=font).grid(column=0, row=2, sticky="E")
            subnet_host_bits = BorderedFrame(subnet_frame, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=2, justify=tk.CENTER, textvariable=self.fields.subnet.subnet_bits, bd=0, font=font, state="readonly", highlightbackground=self.colors["subnet"], readonlybackground=self.colors["subnet"])
            subnet_host_bits.grid(column=1, row=2, pady=5, sticky="W")

            tk.Label(subnet_frame, text="Host Bits: ", font=font).grid(column=2, row=2, sticky="E")
            subnet_bits = BorderedFrame(subnet_frame, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=2, justify=tk.CENTER, textvariable=self.fields.subnet.host_bits, bd=0, font=font, state="readonly", highlightbackground=self.colors["host"], readonlybackground=self.colors["host"])
            subnet_bits.grid(column=3, row=2, padx=(5, 0), pady=5, sticky="W")

            tk.Label(subnet_frame, text="Hosts / Subnet: ", font=font).grid(column=0, row=3, sticky="E")
            addresses_per_subnet = BorderedFrame(subnet_frame, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=15, justify=tk.CENTER, textvariable=self.fields.subnet.addresses_per_subnet, font=font, state="readonly", readonlybackground="systemTextBackgroundColor")
            addresses_per_subnet.grid(column=1, row=3, pady=5, sticky="W", columnspan=3)

            tk.Label(subnet_frame, text="No. of Subnets: ", font=font).grid(column=0, row=4, sticky="E")
            number_of_subnets = BorderedFrame(subnet_frame, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=15, justify=tk.CENTER, textvariable=self.fields.subnet.number_of_subnets, font=font, state="readonly", readonlybackground="systemTextBackgroundColor")
            number_of_subnets.grid(column=1, row=4, pady=5, sticky="W", columnspan=3)

            self.fields.subnet.subnet_bits.trace("w", lambda *args: self._set_subnet(*args))
            self.fields.ip.long.trace("w", lambda *args: self._reset_subnet(*args))
            self.fields.cidr_notation.trace("w", lambda *args: self._reset_subnet(*args))

            # class_frame = tk.LabelFrame(self, text="Class", font=('TkFixedFont', 10))
            # class_frame.grid(column=0, row=3, ipadx=5, ipady=5, padx=5, sticky="NSEW")
            # cframe = IPv4ClassFrame(class_frame, self.fields)
            # cframe.grid(row=0, column=0,  sticky="NSEW")

            special_frame = tk.LabelFrame(self, text="IP Info", font=('TkFixedFont', 10))
            special_frame.grid(column=1, row=3, ipadx=5, ipady=5, padx=5, sticky="NSEW", columnspan=4)
            sframe =  IPv4SpecialFrame(special_frame, self.fields)
            sframe.grid(row=0, column=0, sticky="NSEW")

            fr = tk.Frame(self.inner)

            self.class_range = {
                'A': "0 - 127",
                'B': "128 - 191", 
                'C': "192 - 223", 
                'D': "224 - 239", 
                'E': "240 - 255"
            }

            self.class_range_var = tk.StringVar(value=self.class_range['A'])

            tk.Label(fr, text="Class:", font=font).grid(row=0, column=0, padx=5, sticky="E")
            BorderedFrame(fr, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=2, justify=tk.CENTER, textvariable=self.fields.ip_class, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=1, row=0, padx=5, pady=5, sticky="W")


            fr2 = tk.Frame(self.inner)
            tk.Label(fr2, text="First Octet Range: ", font=font).grid(column=0, row=1, sticky="E")
            BorderedFrame(fr2, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=10, justify=tk.CENTER, textvariable=self.class_range_var, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=1, row=1, padx=5, pady=5, sticky="W")

            self.fields.ip_class.trace("w", lambda *args: self._set_class(*args))

            fr.grid(row=bit_significance_row, column=3, columnspan=2, rowspan=1, sticky="W")
            fr2.grid(row=bit_significance_row, column=4, columnspan=2, rowspan=1, sticky="W")

    
    def _set_mask_colors(self, *args, bit_index: int):
        if self.fields.mask_map[bit_index].get() == 'H':
            self.ip_octet_frames[bit_index // 8].cells[bit_index % 8].interior.config(bg=self.colors["host"])
            self.ip_bitmap_frames[bit_index // 8].cells[bit_index % 8].interior.config(bg=self.colors["host"])
            self.ip_mask_frames[bit_index // 8].cells[bit_index % 8].interior.config(bg=self.colors["host"])
        else:
            self.ip_octet_frames[bit_index // 8].cells[bit_index % 8].interior.config(bg=self.colors["network"])
            self.ip_bitmap_frames[bit_index // 8].cells[bit_index % 8].interior.config(bg=self.colors["network"])
            self.ip_mask_frames[bit_index // 8].cells[bit_index % 8].interior.config(bg=self.colors["network"])

    def _set_subnet_colors(self, *args, bit_index: int):
        if self.fields.subnet_map[bit_index].get() == 'H':
            self.ip_octet_frames[bit_index // 8].cells[bit_index % 8].interior.config(bg=self.colors["host"])
            self.ip_bitmap_subnet_frames[bit_index // 8].cells[bit_index % 8].interior.config(bg=self.colors["host"])
        elif self.fields.subnet_map[bit_index].get() == 'S':
            self.ip_octet_frames[bit_index // 8].cells[bit_index % 8].interior.config(bg=self.colors["subnet"])
            self.ip_bitmap_subnet_frames[bit_index // 8].cells[bit_index % 8].interior.config(bg=self.colors["subnet"])
        else:
            self.ip_octet_frames[bit_index // 8].cells[bit_index % 8].interior.config(bg=self.colors["network"])
            self.ip_bitmap_subnet_frames[bit_index // 8].cells[bit_index % 8].interior.config(bg=self.colors["network"])

    def _set_subnet(self, *args):
        subnet_bits = self._get_subnet_bits()
        host_bits = self.fields.host_bits.get()

        if subnet_bits == 0:
            for i in range(32):
                mask_bit = self.fields.mask_map[i].get()
                self.fields.subnet_map[i].set(mask_bit)

                if mask_bit == 'N':
                    self.ip_octet_frames[i // 8].cells[i % 8].interior.config(bg=self.colors["network"])
                    self.ip_bitmap_subnet_frames[i // 8].cells[i % 8].interior.config(bg=self.colors["network"])
                else:
                    self.ip_octet_frames[i // 8].cells[i % 8].interior.config(bg=self.colors["host"])
                    self.ip_bitmap_subnet_frames[i // 8].cells[i % 8].interior.config(bg=self.colors["host"])
        else:
            net_bits = self.fields.network_bits.get()
            subnet_bitmap = 'N' * net_bits + 'S' * subnet_bits + 'H' * (host_bits - subnet_bits)
            for i in range(32):
                self.fields.subnet_map[i].set(subnet_bitmap[i])
        
        self.fields.subnet.host_bits.set(host_bits - subnet_bits)
        self.fields.subnet.number_of_subnets.set(1 << subnet_bits)
        addresses = 1 << (host_bits - subnet_bits)
        self.fields.subnet.addresses_per_subnet.set(addresses - 2 if addresses > 2 else 0)
        self.fields.subnet.cidr_prefix.set('/' + str(self.fields.network_bits.get() + subnet_bits))


    def _get_subnet_bits(self):
        try:
            return int(self.fields.subnet.subnet_bits.get(), 10)
        except ValueError:
            return 0
        

    def _draw_arrow(self, event, canvas, arrowstyle):
        canvas.delete("arrow")

        y = canvas.winfo_height() // 2

        canvas.create_line(0, y, canvas.winfo_width() - 7, y, arrow=arrowstyle, tags="arrow")


    def _set_class(self, *args):
        colors = self.class_colors[self.fields.ip_class.get()]
        for i in range(4):
            self.ip_class_arrows.cells[i].interior.label.config(fg=colors[i])

        self.class_range_var.set(self.class_range[self.fields.ip_class.get()])


    def _reset_subnet(self, *args):
        host_bits = self.fields.host_bits.get()
        self.fields.subnet.host_bits.set(host_bits)
        self.fields.subnet.subnet_bits.set(0)
        self.subnet_spinbox.delete(0, "end")
        self.subnet_spinbox.insert(0, 0)
        self.subnet_spinbox.config(to=host_bits)
        
        for i in range(32):
            self.fields.subnet_map[i].set(self.fields.mask_map[i].get())
        
        self.fields.subnet.addresses_per_subnet.set(self.fields.usable_hosts.get())
        self.fields.subnet.number_of_subnets.set(1)
        self.fields.subnet.cidr_prefix.set('/0')


class IPv4ClassFrame(tk.Frame):
    def __init__(self, 
                 container,
                 fields: IPv4SummaryFields,
                 bordercolor: str = "systemTextColor",
                 outerborderwidths: BorderWidths = BorderWidths(2, 2, 2, 2),
                 innerborderwidth: int = 1,
                 width: str | float = 15, 
                 height: str | float = 15,
                 font=('TkFixedFont', 10),
                 dotfont=('TkFixedFont', 12, 'bold'),
                 justify=tk.CENTER,
                 **kwargs):
            tk.Frame.__init__(self, container)
            self.class_range = {
                'A': "0 - 127",
                'B': "128 - 191", 
                'C': "192 - 223", 
                'D': "224 - 239", 
                'E': "240 - 255"
            }
            self.fields = fields
            self.inner = tk.Frame(self)
            self.inner.grid(column=0, row=0, pady=5, padx=5, sticky="NSEW")
            self.class_range_var = tk.StringVar(value=self.class_range['A'])

            tk.Label(self.inner, text="In classful network architecture, this IP is:", font=font).grid(column=0, row=0, sticky="E", columnspan=4)

            tk.Label(self.inner, text="Class: ", font=font).grid(column=0, row=1, sticky="E")
            BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=2, justify=tk.CENTER, textvariable=self.fields.ip_class, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=1, row=1, padx=5, pady=5, sticky="W")

            tk.Label(self.inner, text="First Octet Range: ", font=font).grid(column=0, row=2, sticky="E")
            BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=10, justify=tk.CENTER, textvariable=self.class_range_var, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=1, row=2, padx=5, pady=5, sticky="W")

            self.fields.ip_class.trace("w", lambda *args: self._set_class(*args))
    
    def _set_class(self, *args):
        self.class_range_var.set(self.class_range[self.fields.ip_class.get()])


class IPv4SpecialFrame(tk.Frame):
    def __init__(self, 
                 container,
                 fields: IPv4SummaryFields,
                 bordercolor: str = "systemTextColor",
                 outerborderwidths: BorderWidths = BorderWidths(2, 2, 2, 2),
                 innerborderwidth: int = 1,
                 width: str | float = 15, 
                 height: str | float = 15,
                 font=('TkFixedFont', 10),
                 dotfont=('TkFixedFont', 12, 'bold'),
                 justify=tk.CENTER,
                 **kwargs):
            tk.Frame.__init__(self, container)

            self.special_iana_rfc = {
                '"This network"': [('[RFC791], Section 3.2', 'https://www.rfc-editor.org/rfc/rfc791.html#section-3.2'), ('', '')],
                '"This host on this network"': [('[RFC1122], Section 3.2.1.3', 'https://www.rfc-editor.org/rfc/rfc1122.html#page-29'), ('', '')],
                'Shared Address Space': [('[RFC6598]', 'https://www.rfc-editor.org/rfc/rfc6598.html'), ('', '')],
                'Loopback': [('[RFC1122], Section 3.2.1.3', 'https://www.rfc-editor.org/rfc/rfc1122.html#page-29'), ('', '')],
                'Link Local': [('[RFC3927]', 'https://www.rfc-editor.org/rfc/rfc3927.html'), ('', '')],
                'IETF Protocol Assignments': [('[RFC6890], Section 2.1', 'https://www.rfc-editor.org/rfc/rfc6890.html#section-2.1'), ('', '')],
                'IPv4 Service Continuity Prefix': [('[RFC7335]', 'https://www.rfc-editor.org/rfc/rfc7335.html'), ('', '')],
                'IPv4 dummy address': [('[RFC7600]', 'https://www.rfc-editor.org/rfc/rfc7600.html'), ('', '')],
                'Port Control Protocol Anycast': [('[RFC7723]', 'https://www.rfc-editor.org/rfc/rfc7723.html'), ('', '')],
                'Traversal Using Relays around NAT Anycast': [('[RFC8155]', 'https://www.rfc-editor.org/rfc/rfc8155.html'), ('', '')],
                'NAT64/DNS64 Discovery': [('[RFC8880]', 'https://www.rfc-editor.org/rfc/rfc8880.html'), ('[RFC7050], Section 2.2', 'https://www.rfc-editor.org/rfc/rfc7050.html#section-2.2')],
                'Documentation (TEST-NET-1)': [('[RFC5737]', 'https://www.rfc-editor.org/rfc/rfc5737.html'), ('', '')],
                'AS112-v4': [('[RFC7535]', 'https://www.rfc-editor.org/rfc/rfc7535.html'), ('', '')],
                'AMT': [('[RFC7450]', 'https://www.rfc-editor.org/rfc/rfc7450.html'), ('', '')],
                'Direct Delegation AS112 Service': [('[RFC7534]', 'https://www.rfc-editor.org/rfc/rfc7534.html'), ('', '')],
                'Benchmarking': [('[RFC2544]', 'https://www.rfc-editor.org/rfc/rfc2544.html'), ('', '')],
                'Documentation (TEST-NET-2)': [('[RFC5737]', 'https://www.rfc-editor.org/rfc/rfc5737.html'), ('', '')],
                'Documentation (TEST-NET-3)': [('[RFC5737]', 'https://www.rfc-editor.org/rfc/rfc5737.html'), ('', '')],
                'Reserved': [('[RFC1112], Section 4', 'https://www.rfc-editor.org/rfc/rfc1112.html#section-4'), ('', '')],
                'Limited Broadcast': [('[RFC8190]', 'https://www.rfc-editor.org/rfc/rfc8190.html'), ('[RFC919], Section 7', 'https://www.rfc-editor.org/rfc/rfc919.html#section-7')],
                'N/A' : [('', ''), ('', '')]
            }

            self.fields = fields
            self.inner = tk.Frame(self)
            self.inner.grid(column=0, row=0, pady=5, padx=5, sticky="NSEW")

            type_frame = tk.Frame(self.inner)
            type_frame.grid(row=0, column=1, sticky="NSEW")

            tk.Label(self.inner, text="Type: ", font=font).grid(column=0, row=0, sticky="E")
            BorderedFrame(type_frame, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=10, justify=tk.CENTER, textvariable=self.fields.public_or_private, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=1, row=0, padx=5, pady=(5, 10), sticky="W")
            self.rfc_private_source = tk.Label(type_frame, text="[RFC1918]", font=('TkFixedFont', 10, 'italic'), cursor="hand2", justify=tk.LEFT, anchor="w")
            self.rfc_private_source.grid(column=2, row=0, sticky="W")
            self.rfc_private_source.bind("<Button-1>", lambda e: webbrowser.open_new("https://datatracker.ietf.org/doc/html/rfc1918"))

            tk.Label(self.inner, text="Special: ", font=font).grid(column=0, row=2, sticky="E")
            BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=40, justify=tk.CENTER, textvariable=self.fields.special_notes, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=1, row=2, padx=5, sticky="W", columnspan=2)
            self.special_rfc_1 = tk.Label(self.inner, text=self.special_iana_rfc['"This host on this network"'][0][0], font=('TkFixedFont', 10, 'italic'), width=25, cursor="hand2", justify=tk.LEFT, anchor="w")
            self.special_rfc_1.grid(column=1, row=3, sticky="W")
            self.special_rfc_1.bind("<Button-1>", lambda e: webbrowser.open_new(self.special_iana_rfc['"This host on this network"'][0][1]))

            self.special_rfc_2 = tk.Label(self.inner, text=self.special_iana_rfc['"This host on this network"'][1][0], width=25, font=('TkFixedFont', 10, 'italic'), justify=tk.LEFT, anchor="w")
            self.special_rfc_2.grid(column=1, row=4, sticky="W")
            
            self.source =  tk.Label(self.inner, text="Source: IANA IPv4\nSpecial-Purpose Address Registry", font=('TkFixedFont', 8), cursor="hand2", justify=tk.LEFT, anchor="w")
            self.source.grid(column=2, row=0, sticky="NE", columnspan=2, pady=(10, 0))
            self.source.bind("<Button-1>", lambda e: webbrowser.open_new("https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml"))
        
            self.fields.special_notes.trace("w", lambda *args: self._set_special(*args))

    
    
    def _set_special(self, *args):
        rfc = self.special_iana_rfc[self.fields.special_notes.get()]
        self.special_rfc_1.unbind("<Button-1>")
        self.special_rfc_2.unbind("<Button-1>")

        self.special_rfc_1.config(text=rfc[0][0])
        self.special_rfc_2.config(text=rfc[1][0])

        if rfc[0] != ('', ''):
            self.special_rfc_1.bind("<Button-1>", lambda e: webbrowser.open_new(rfc[0][1]))
            self.special_rfc_1.config(cursor="hand2")
        else:
            self.special_rfc_1.config(cursor='')
        
        if rfc[1] != ('', ''):
            self.special_rfc_2.bind("<Button-1>", lambda e: webbrowser.open_new(rfc[1][1]))
            self.special_rfc_2.config(cursor="hand2")
        else:
            self.special_rfc_2.config(cursor='')

            


class IPv4MaskingFrame(tk.Frame):
    def __init__(self, 
                 container,
                 names: tuple,
                 ip: IPv4SummaryAddressFields,
                 mask: IPv4SummaryAddressFields, 
                 result: IPv4SummaryAddressFields,
                 bordercolor: str = "systemTextColor",
                 outerborderwidths: BorderWidths = BorderWidths(2, 2, 2, 2),
                 innerborderwidth: int = 1,
                 width: str | float = 15, 
                 height: str | float = 15,
                 font=('TkFixedFont', 10),
                 dotfont=('TkFixedFont', 12, 'bold'),
                 justify=tk.CENTER,
                 **kwargs):
            tk.Frame.__init__(self, container)

            self.ip_octet_frames = []
            self.mask_octet_frames = []
            self.result_octet_frames = []
            self.arrow_octet_frames = []

            self.ip_quad_frames = []
            self.mask_quad_frames = []
            self.result_quad_frames = []
            self.arrow_quad_frames = []

            bg = self.cget("bg")
            
            tk.Label(self, text=f"{names[0]}:", compound=tk.CENTER, font=font).grid(row=0, column=0, padx=5, sticky="E")
            tk.Label(self, text=f"{names[1]}:", compound=tk.CENTER, font=font).grid(row=1, column=0, padx=5, sticky="E")
            tk.Label(self, text=f"{names[2]}:", compound=tk.CENTER, font=font).grid(row=3, column=0, padx=5, sticky="E")
            tk.Label(self, text=f"{names[3]}", compound=tk.CENTER, font=('TkFixedFont', 10, 'bold')).grid(row=2, column=0, padx=5, sticky="E")

            idx = 1
            for i in range(0, 32, 8):
                octet = CombFrame(self, 
                                varslist=ip.binary_bits[i:i+8], 
                                bordercolor=bordercolor, 
                                outerborderwidths=outerborderwidths, 
                                innerborderwidth=innerborderwidth, 
                                width=width, 
                                height=height, 
                                font=font,
                                **kwargs)
                octet.grid(row=0, column=idx, pady=5, sticky="NSEW")
                mask_octet = CombFrame(self, 
                                varslist=mask.binary_bits[i:i+8], 
                                bordercolor=bordercolor, 
                                outerborderwidths=outerborderwidths, 
                                innerborderwidth=innerborderwidth, 
                                width=width, 
                                height=height, 
                                font=font,
                                **kwargs)
                mask_octet.grid(row=1, column=idx, pady=5, sticky="NSEW")
                result_octet = CombFrame(self, 
                                varslist=result.binary_bits[i:i+8], 
                                bordercolor=bordercolor, 
                                outerborderwidths=outerborderwidths, 
                                innerborderwidth=innerborderwidth, 
                                width=width, 
                                height=height, 
                                font=font,
                                **kwargs)
                result_octet.grid(row=3, column=idx, pady=5, sticky="NSEW")
                arrow_octet = CombFrame(self, 
                                textlist=["\u21E9"]*8,
                                bordercolor=bg,
                                outerborderwidths=outerborderwidths, 
                                innerborderwidth=innerborderwidth, 
                                width=width, 
                                height=height, 
                                font=font,
                                **kwargs)
                arrow_octet.grid(row=2, column=idx, sticky="NSEW")
                idx += 1
                self.ip_octet_frames.append(octet)
                self.mask_octet_frames.append(mask_octet)
                self.result_octet_frames.append(result_octet)
                            
                if idx < 7:
                    tk.Label(self, text=" ", font=dotfont).grid(row=0, column=idx)
                    tk.Label(self, text=" ", font=dotfont).grid(row=1, column=idx)
                    tk.Label(self, text=" ", font=dotfont).grid(row=3, column=idx)
                    idx += 1

            octet_names = ["First", "Second", "Third", "Fourth"]

            tk.Label(self, text="=", font=dotfont, anchor=tk.CENTER).grid(row=0, column=idx)
            tk.Label(self, text="=", font=dotfont, anchor=tk.CENTER).grid(row=1, column=idx)
            tk.Label(self, text="=", font=dotfont, anchor=tk.CENTER).grid(row=3, column=idx)
            idx += 1
            for i in range(4):
                octet = WidgetCombFrame(self, outerborderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", widget=FixedSizeFramedLabel, width=35, height=15, justify=tk.CENTER, varslist=[ip.decimal_octets[i]], font=font, background="systemTextBackgroundColor")
                octet.grid(row=0, column=idx, pady=5, sticky="NSEW")

                mask_octet = WidgetCombFrame(self, outerborderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", widget=FixedSizeFramedLabel, width=35, height=15, justify=tk.CENTER, varslist=[mask.decimal_octets[i]], font=font, background="systemTextBackgroundColor")
                mask_octet.grid(row=1, column=idx, pady=5, sticky="NSEW")

                result_octet = WidgetCombFrame(self, outerborderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", widget=FixedSizeFramedLabel, width=35, height=15, justify=tk.CENTER, varslist=[result.decimal_octets[i]], font=font, background="systemTextBackgroundColor")
                result_octet.grid(row=3, column=idx, pady=5, sticky="NSEW")

                arrow_octet = WidgetCombFrame(self, outerborderwidths=BorderWidths(2,2,2,2), bordercolor=bg, widget=FixedSizeFramedLabel, width=35, height=15, justify=tk.CENTER, textlist=["\u21E9"], font=font)
                arrow_octet.grid(row=2, column=idx, sticky="NSEW")
                
                self.ip_quad_frames.append(octet)
                self.mask_quad_frames.append(mask_octet)
                self.result_quad_frames.append(result_octet)

                Tooltip(self.ip_quad_frames[i], f"{names[0]} {octet_names[i]} Octet")
                Tooltip(self.mask_quad_frames[i], f"{names[1]} {octet_names[i]} Octet")
                Tooltip(self.result_quad_frames[i], f"{names[2]} {octet_names[i]} Octet")

                idx += 1
                
                if idx < 15:
                    tk.Label(self, text=".", font=dotfont).grid(row=0, column=idx)
                    tk.Label(self, text=".", font=dotfont).grid(row=1, column=idx)
                    tk.Label(self, text=".", font=dotfont).grid(row=3, column=idx)
                    idx += 1


class IPv4SummaryFrame(tk.Frame):
    def __init__(self, 
                 container, 
                 fields: IPv4SummaryFields,
                 cidr_info: list[CIDRInfo],
                 bordercolor: str = "systemTextColor",
                 outerborderwidths: BorderWidths = BorderWidths(2, 2, 2, 2),
                 innerborderwidth: int = 1,
                 width: str | float = 15, 
                 height: str | float = 15,
                 font=('TkFixedFont', 10),
                 dotfont=('TkFixedFont', 12, 'bold'),
                 justify=tk.CENTER,
                 **kwargs):
        tk.Frame.__init__(self, container)
        self.fields = fields
        self.cidr_info = cidr_info
        self.inner = tk.Frame(self)
        self.inner.grid(row=0, column=0)

        title_col = 0
        dec_col = 1
        bin_col = 2
        hex_col = 3
        long_col = 4

        pady = 5
        padx = 7
        label_padx = (5, 0)
        widths = [16, 35, 12, 15]



        tk.Label(self.inner, text="IP Address:", font=font).grid(column=title_col, row=0, padx=label_padx)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[0], justify=tk.CENTER, textvariable=self.fields.ip.dotted_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=dec_col, row=0, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[1], justify=tk.CENTER, textvariable=self.fields.ip.binary_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=bin_col, row=0, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[2], justify=tk.CENTER, textvariable=self.fields.ip.hex_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=hex_col, row=0, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[3], justify=tk.CENTER, textvariable=self.fields.ip.long, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=long_col, row=0, padx=padx, pady=pady)


        tk.Label(self.inner, text="Netmask:", font=font).grid(column=title_col, row=1, padx=label_padx)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[0], justify=tk.CENTER, textvariable=self.fields.netmask.dotted_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=dec_col, row=1, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[1], justify=tk.CENTER, textvariable=self.fields.netmask.binary_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=bin_col, row=1, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[2], justify=tk.CENTER, textvariable=self.fields.netmask.hex_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=hex_col, row=1, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[3], justify=tk.CENTER, textvariable=self.fields.netmask.long, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=long_col, row=1, padx=padx, pady=pady)


        tk.Label(self.inner, text="Wildcard:", font=font).grid(column=title_col, row=2, padx=label_padx)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[0], justify=tk.CENTER, textvariable=self.fields.wildcard.dotted_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=dec_col, row=2, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[1], justify=tk.CENTER, textvariable=self.fields.wildcard.binary_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=bin_col, row=2, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[2], justify=tk.CENTER, textvariable=self.fields.wildcard.hex_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=hex_col, row=2, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[3], justify=tk.CENTER, textvariable=self.fields.wildcard.long, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=long_col, row=2, padx=padx, pady=pady)


        tk.Label(self.inner, text="Network:", font=font).grid(column=title_col, row=3, padx=label_padx)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[0], justify=tk.CENTER, textvariable=self.fields.network.dotted_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=dec_col, row=3, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[1], justify=tk.CENTER, textvariable=self.fields.network.binary_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=bin_col, row=3, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[2], justify=tk.CENTER, textvariable=self.fields.network.hex_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=hex_col, row=3, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[3], justify=tk.CENTER, textvariable=self.fields.network.long, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=long_col, row=3, padx=padx, pady=pady)


        tk.Label(self.inner, text="Broadcast:", font=font).grid(column=title_col, row=4, padx=label_padx)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[0], justify=tk.CENTER, textvariable=self.fields.broadcast.dotted_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=dec_col, row=4, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[1], justify=tk.CENTER, textvariable=self.fields.broadcast.binary_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=bin_col, row=4, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[2], justify=tk.CENTER, textvariable=self.fields.broadcast.hex_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=hex_col, row=4, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[3], justify=tk.CENTER, textvariable=self.fields.broadcast.long, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=long_col, row=4, padx=padx, pady=pady)


        tk.Label(self.inner, text="Min Host:", font=font).grid(column=title_col, row=5, padx=label_padx)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[0], justify=tk.CENTER, textvariable=self.fields.start_ip.dotted_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=dec_col, row=5, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[1], justify=tk.CENTER, textvariable=self.fields.start_ip.binary_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=bin_col, row=5, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[2], justify=tk.CENTER, textvariable=self.fields.start_ip.hex_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=hex_col, row=5, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[3], justify=tk.CENTER, textvariable=self.fields.start_ip.long, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=long_col, row=5, padx=padx, pady=pady)
        
        tk.Label(self.inner, text="Max Host:", font=font).grid(column=title_col, row=6, padx=label_padx)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[0], justify=tk.CENTER, textvariable=self.fields.end_ip.dotted_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=dec_col, row=6, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[1], justify=tk.CENTER, textvariable=self.fields.end_ip.binary_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=bin_col, row=6, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[2], justify=tk.CENTER, textvariable=self.fields.end_ip.hex_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=hex_col, row=6, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[3], justify=tk.CENTER, textvariable=self.fields.end_ip.long, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=long_col, row=6, padx=padx, pady=pady)


        tk.Label(self.inner, text="Next Subnet:", font=font).grid(column=title_col, row=7, padx=label_padx)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[0], justify=tk.CENTER, textvariable=self.fields.next_subnet.dotted_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=dec_col, row=7, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[1], justify=tk.CENTER, textvariable=self.fields.next_subnet.binary_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=bin_col, row=7, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[2], justify=tk.CENTER, textvariable=self.fields.next_subnet.hex_quad, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=hex_col, row=7, padx=padx, pady=pady)
        BorderedFrame(self.inner, borderwidths=BorderWidths(2,2,2,2), bordercolor="systemTextColor", interior=tk.Entry, width=widths[3], justify=tk.CENTER, textvariable=self.fields.next_subnet.long, font=font, state="readonly", readonlybackground="systemTextBackgroundColor").grid(column=long_col, row=7, padx=padx, pady=pady)



class CIDRVisualizer(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("CIDR Visualizer")

        self.fields = IPv4SummaryFields(
            ip=self._init_fields(),
            netmask=self._init_fields(),
            wildcard=self._init_fields(),
            network=self._init_fields(),
            broadcast=self._init_fields(),
            start_ip=self._init_fields(),
            end_ip=self._init_fields(),
            next_subnet=self._init_fields(),
            public_or_private=tk.StringVar(value="Public"),
            special_notes=tk.StringVar(value='"This host on this network"'),
            subnet=IPv4SubnetFields(cidr_prefix=tk.StringVar(value='/0'),
                                    addresses_per_subnet=tk.IntVar(value=4294967294),
                                    subnet_bits=tk.StringVar(value=0),
                                    host_bits=tk.IntVar(value=32),
                                    number_of_subnets=tk.IntVar(value=1)),
            network_bits=tk.IntVar(value=0),
            host_bits=tk.IntVar(value=32),
            cidr_notation=tk.StringVar(value='0.0.0.0/0'),
            ip_class=tk.StringVar(value='A'),
            total_addresses=tk.IntVar(value=4294967296),
            usable_hosts=tk.IntVar(value=4294967294),
            mask_map=[tk.StringVar(value='H') for _ in range(32)],
            subnet_map=[tk.StringVar(value='H') for _ in range(32)]
        )
        self.cidr_info = [CIDRInfo(i) for i in range(33)]

        left_frame = tk.Frame(self)
        left_frame.grid(row=0, column=0, sticky="NSEW")

        right_frame = tk.Frame(self)
        right_frame.grid(row=0, column=1, sticky="NSEW", ipadx=5, ipady=5)

        #background="systemTextBackgroundColor"
        ifm = tk.LabelFrame(left_frame, text="Input", font=('TkFixedFont', 10))
        ifm.grid(column=0, row=0, sticky="NSEW")
        input_frame =  IPv4EntryFrame(ifm, self.fields, self.cidr_info)
        input_frame.grid(column=0, row=0, sticky="NSEW")

        sfm = tk.LabelFrame(left_frame, text="Summary", font=('TkFixedFont', 10))
        sfm.grid(column=0, row=1, sticky="NSEW")
        summary_frame = IPv4SummaryFrame(sfm, self.fields, self.cidr_info)
        summary_frame.grid(column=1, row=0, ipadx=5, ipady=5, sticky="NSEW")

        input_vis = InputSummaryImageFrame(right_frame, self.fields.ip, self.fields.netmask, self.fields)
        input_vis.grid(column=0, row=1, ipadx=5, ipady=5, padx=5, columnspan=2, sticky="NSEW")

        nvis = tk.LabelFrame(right_frame, text="Network Calculation", font=('TkFixedFont', 10))
        nvis.grid(column=0, row=2, padx=5, sticky="NSEW")
        
        bvis = tk.LabelFrame(right_frame, text="Broadcast Calculation", font=('TkFixedFont', 10))
        bvis.grid(column=0, row=3, padx=5, sticky="NSEW")

        tk.Label(nvis, text="IP & Netmask = Network IP", font=('TkFixedFont', 10)).grid(column=0, row=1, ipadx=5, ipady=5, padx=5, pady=5, sticky="NSEW")
        network_masking = IPv4MaskingFrame(nvis, ("Input", "Netmask", "Network", "AND"), self.fields.ip, self.fields.netmask, self.fields.network)
        network_masking.grid(column=0, row=0, sticky="NSEW")

        tk.Label(bvis, text="IP | Wildcard Mask = Broadcast IP", font=('TkFixedFont', 10),).grid(column=0, row=1, ipadx=5, ipady=5, padx=5, pady=5, sticky="NSEW")
        broadcast_masking = IPv4MaskingFrame(bvis, ("Input", "Wildcard", "Broadcast", "OR"), self.fields.ip, self.fields.wildcard, self.fields.broadcast)
        broadcast_masking.grid(column=0, row=0, sticky="NSEW")

        self.update()

        print(left_frame.winfo_width())
        print(left_frame.winfo_height())

        self.mainloop()

    def _init_fields(self):
        return IPv4SummaryAddressFields(
            dotted_quad=tk.StringVar(value='0.0.0.0'),
            binary_quad=tk.StringVar(value='00000000.00000000.00000000.00000000'),
            hex_quad=tk.StringVar(value='00.00.00.00'),
            long=tk.StringVar(value=0),
            binary_bits=[tk.StringVar(value=0) for _ in range(32)],
            decimal_octets=[tk.StringVar(value=0) for _ in range(4)],
            hex_octets=[tk.StringVar(value='00') for _ in range(4)]
        )

if __name__ == "__main__":
    root = CIDRVisualizer()